<!doctype html>
<html lang="ro">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Backtracking • Theory</title>
  <link rel="stylesheet" href="assets/style.css" />
  <meta name="description" content="Backtracking — site de prezentare multi-page." />
</head>

<body>
  <header class="topbar">
    <nav class="nav" aria-label="Primary navigation">
      <div class="brand">
        <div class="badge">BACKTRACKING</div>
        <div class="small">compact • curat • rapid</div>
      </div>
      <div class="links">
        <a class="navlink" data-nav href="index.html">Acasa</a>
        <a class="navlink" data-nav href="problems.html">Probleme</a>
        <a class="navlink" data-nav href="theory.html">Teorie</a>
        <a class="navlink" data-nav href="bibliography.html">Bibliografie</a>
      </div>
    </nav>
  </header>
  <main class="container">


    <div class="breadcrumbs" aria-label="Breadcrumbs">
      <a href="index.html">Acasa</a><span>›</span><span>Teorie</span>
    </div>

    <section class="hero" style="padding-top: 18px;">
      <div class="card pad">
        <div class="sectionTitle">Teorie</div>
        <h1 class="h1">Introducere — Backtracking</h1>
        <p class="p">
          Metoda backtracking se foloseşte în rezolvarea problemelor care îndeplinesc simultan următoarele condiţii:
        </p>
        <ul class="list">
          <li>soluţia poate fi pusă sub forma unui vector <span class="code">S = x1, x2, ..., xn</span>, cu
            <span class="code">x1 ∈ A1</span>, <span class="code">x2 ∈ A2</span>, ..., <span class="code">xn ∈
              An</span>;
          </li>
          <li>mulţimile <span class="code">A1, A2, ..., An</span> sunt finite, iar elementele lor se află într-o relaţie
            de ordine bine stabilită;</li>
          <li>nu se dispune de o altă metodă de rezolvare, mai rapidă.</li>
        </ul>
      </div>

      <div class="card pad">
        <div class="sectionTitle">Principiu</div>
        <h2 class="h2">Pas înainte / pas înapoi</h2>
        <p class="p">Metoda backtracking are la bază un principiu simplu:</p>
        <ul class="list">
          <li>dacă în procesul de generare a lui <span class="code">S</span>, pentru componenta <span
              class="code">k</span>, după ce am generat
            <span class="code">x1, x2, ..., xk</span> constatăm că <span class="code">xk</span> nu este bine aleasă (nu
            se va ajunge la o soluţie),
            nu trecem la componenta <span class="code">k+1</span>;
          </li>
          <li>reluăm căutarea pentru altă valoare a componentei <span class="code">k</span>, iar dacă aceasta nu există,
            reluăm căutarea pentru componenta <span class="code">k-1</span>.</li>
        </ul>
        <hr class="sep" />
        <p class="p">
          Observaţi: după ce analizăm valorile posibile pentru componenta <span class="code">k</span>, avem două
          posibilităţi:
          ori trecem la <span class="code">k+1</span> (pas înainte), ori mergem la <span class="code">k-1</span> (pas
          înapoi).
        </p>
      </div>
    </section>

    <section>
      <div class="card pad">
        <div class="sectionTitle">Exemple</div>
        <h1 class="h3">Ilustrare pas-cu-pas</h1>
        <ul class="list">
          <li>Componenta 1 va memora numărul 1. Întrucâ există permutări care încep cu 1, trecem la
            elementul 2 - facem pasul înainte. <span class="code">1</span><span class="code"></span><span
              class="code"></span>
          </li>
          <li>
            Componenta 2 va memora numărul 1. <span class="code">1</span><span class="code">1</span><span
              class="code"></span>
          </li>
          <li>Nu există permutări care încep cu 1,1, motiv
            pentru care, pentru aceeaşi componentă, vom
            reţine valoarea următoare, adică 2. Întrucât
            există permutări care încep cu 1,2, vom trece la
            elementul 3 (înainte). ​<span class="code">1</span><span class="code">2</span><span class="code"></span>
          </li>
          <li>
            Componenta 3 va memora numărul 1.
            ​<span class="code">1</span><span class="code">2</span><span class="code">1</span>
          </li>
          <li>
            Nu există permutări care sunt de forma 1,2,1,
            motiv pentru care aceeaşi componentă va reţine
            numărul următor, 2.
            ​<span class="code">1</span><span class="code">2</span><span class="code">2</span>
          </li>
          <li>
            Nu există permutări care sunt de forma 1,2,2, motiv pentru care
            aceeaşi componentă va memora numărul următor, adică 3. Am
            obţinut deja o primă soluţie şi o afişăm.
            ​<span class="code">1</span><span class="code">2</span><span class="code">3</span>
          </li>
          <li>
            Pentru componenta 3, nu există o altă valoare pe care o putem
            utiliza. Din acest motiv, vom trece la elementul 2, (înapoi).
            Componenta 2 are deja memorată valoarea 2. Alegem valoarea
            următoare, 3. Întrucât există permutări care încep cu 1,3, vom
            trece la elementul următor, 3 (înainte).
            ​<span class="code">1</span><span class="code">3</span><span class="code">0</span>
          </li>
          <li>
            Prima valoare care poate fi memorată este 1. Întrucât nu există
            permutări de forma 1,3,1 trecem la valoarea următoare 2. Dar
            1,3,2 este soluţie şi o afişăm.
            ​<span class="code">1</span><span class="code">3</span><span class="code">2</span>
          </li>
          <li>
            Algoritmul continuă până când se ajunge la componenta de
            indice 0. În acel moment, au fost deja afişate toate permutările.
          </li>
        </ul>
      </div>
    </section>

    <footer class="footer">
      <div>© <span data-year></span> • Backtracking</div>

    </footer>
  </main>
  <script src="assets/site.js"></script>
</body>

</html>